---
name: docx
description: "全面的文档创建、编辑和分析，支持跟踪更改、评论、格式保留和文本提取。当Claude需要处理专业文档(.docx文件)时使用：(1)创建新文档，(2)修改或编辑内容，(3)处理跟踪更改，(4)添加评论，或任何其他文档任务"
license: 专有。LICENSE.txt包含完整条款
---

# DOCX创建、编辑和分析

## 概述

用户可能要求您创建、编辑或分析.docx文件的内容。.docx文件本质上是一个包含XML文件和其他资源的ZIP压缩包，您可以读取或编辑这些内容。针对不同的任务，您可以使用不同的工具和工作流程。

## 工作流程决策树

### 读取/分析内容
使用下面的"文本提取"或"原始XML访问"部分

### 创建新文档
使用"创建新Word文档"工作流程

### 编辑现有文档
- **您自己的文档 + 简单更改**
  使用"基本OOXML编辑"工作流程

- **其他人的文档**
  使用**"修订标记工作流程"**（推荐默认）

- **法律、学术、商业或政府文档**
  使用**"修订标记工作流程"**（必需）

## 读取和分析内容

### 文本提取
如果您只需要读取文档的文本内容，应使用pandoc将文档转换为markdown格式。Pandoc提供了出色的文档结构保留支持，并且可以显示跟踪更改：

```bash
# 将文档转换为markdown并保留跟踪更改
pandoc --track-changes=all 文件路径.docx -o 输出.md
# 选项：--track-changes=accept/reject/all
```

### 原始XML访问
对于以下功能，您需要原始XML访问：评论、复杂格式、文档结构、嵌入媒体和元数据。对于这些功能中的任何一项，您需要解包文档并读取其原始XML内容。

#### 解包文件
`python ooxml/scripts/unpack.py <office_file> <output_directory>`

#### 关键文件结构
* `word/document.xml` - 主要文档内容
* `word/comments.xml` - 在document.xml中引用的评论
* `word/media/` - 嵌入的图像和媒体文件
* 跟踪更改使用`<w:ins>`（插入）和`<w:del>`（删除）标签

## 创建新Word文档

从零开始创建新Word文档时，使用**docx-js**，它允许您使用JavaScript/TypeScript创建Word文档。

### 工作流程
1. **强制 - 阅读完整文件**：完整阅读[`docx-js.md`](docx-js.md)（约500行）。**阅读此文件时不要设置任何范围限制**。在继续文档创建之前，阅读完整文件内容以了解详细语法、关键格式规则和最佳实践。
2. 使用Document、Paragraph、TextRun组件创建JavaScript/TypeScript文件（您可以假设所有依赖项都已安装，但如果没有，请参考下面的依赖项部分）
3. 使用Packer.toBuffer()导出为.docx

## 编辑现有Word文档

当编辑现有Word文档时，使用**文档库**（一个用于OOXML操作的Python库）。该库自动处理基础设施设置，并提供文档操作方法。对于复杂场景，您可以通过库直接访问底层DOM。

### 工作流程
1. **强制 - 阅读完整文件**：完整阅读[`ooxml.md`](ooxml.md)（约600行）。**阅读此文件时不要设置任何范围限制**。阅读完整文件内容以了解文档库API和直接编辑文档文件的XML模式。
2. 解包文档：`python ooxml/scripts/unpack.py <office_file> <output_directory>`
3. 创建并运行使用文档库的Python脚本（请参阅ooxml.md中的"文档库"部分）
4. 打包最终文档：`python ooxml/scripts/pack.py <input_directory> <office_file>`

文档库为常见操作提供高级方法，并为复杂场景提供直接DOM访问。

## 修订标记工作流程用于文档审查

此工作流程允许您在实现OOXML之前使用markdown规划全面的跟踪更改。**关键**：对于完整的跟踪更改，必须系统地实现所有更改。

**批处理策略**：将相关更改分组为3-10个更改的批次。这使得调试可管理，同时保持效率。在移动到下一个批次之前测试每个批次。

**原则：最小化、精确的编辑**
实现跟踪更改时，仅标记实际更改的文本。重复未更改的文本会使编辑更难审查且显得不专业。将替换分解为：[未更改文本] + [删除] + [插入] + [未更改文本]。通过从原始文本中提取`<w:r>`元素并重新使用，保留原始运行的RSID用于未更改文本。

示例 - 将句子中的"30天"更改为"60天"：
```python
# 错误 - 替换整个句子
'<w:del><w:r><w:delText>The term is 30 days.</w:delText></w:r></w:del><w:ins><w:r><w:t>The term is 60 days.</w:t></w:r></w:ins>'

# 正确 - 仅标记更改的内容，为未更改文本保留原始<w:r>
'<w:r w:rsidR="00AB12CD"><w:t>The term is </w:t></w:r><w:del><w:r><w:delText>30</w:delText></w:r></w:del><w:ins><w:r><w:t>60</w:t></w:r></w:ins><w:r w:rsidR="00AB12CD"><w:t> days.</w:t></w:r>'
```

### 跟踪更改工作流程

1. **获取markdown表示**：将文档转换为markdown并保留跟踪更改：
   ```bash
   pandoc --track-changes=all 文件路径.docx -o 当前.md
   ```

2. **识别和分组更改**：审查文档并识别所有需要的更改，将它们组织成逻辑批次：

   **定位方法**（用于在XML中查找更改）：
   - 章节/标题编号（例如"第3.2节"、"第四条"）
   - 段落标识符（如果编号）
   - 具有唯一周围文本的grep模式
   - 文档结构（例如"第一段"、"签名块"）
   - **不要使用markdown行号** - 它们不映射到XML结构

   **批次组织**（每组3-10个相关更改）：
   - 按章节："批次1：第2节修订"、"批次2：第5节更新"
   - 按类型："批次1：日期更正"、"批次2：参与方名称更改"
   - 按复杂性：从简单的文本替换开始，然后处理复杂的结构更改
   - 顺序："批次1：第1-3页"、"批次2：第4-6页"

3. **阅读文档并解包**：
   - **强制 - 阅读完整文件**：完整阅读[`ooxml.md`](ooxml.md)（约600行）。**阅读此文件时不要设置任何范围限制**。特别注意"文档库"和"跟踪更改模式"部分。
   - **解包文档**：`python ooxml/scripts/unpack.py <文件.docx> <目录>`
   - **注意建议的RSID**：解包脚本将建议用于跟踪更改的RSID。复制此RSID用于步骤4b。

4. **分批实现更改**：将更改逻辑分组（按章节、按类型或按接近度），并在单个脚本中一起实现它们。这种方法：
   - 使调试更容易（较小的批次 = 更容易隔离错误）
   - 允许增量进度
   - 保持效率（3-10个更改的批次大小效果良好）

   **建议的批次分组：**
   - 按文档章节（例如"第3节更改"、"定义"、"终止条款"）
   - 按更改类型（例如"日期更改"、"参与方名称更新"、"法律术语替换"）
   - 按接近度（例如"第1-3页的更改"、"文档前半部分的更改"）

   对于每批相关更改：

   **a. 将文本映射到XML**：在`word/document.xml`中grep文本以验证文本如何跨`<w:r>`元素拆分。

   **b. 创建并运行脚本**：使用`get_node`查找节点，实现更改，然后`doc.save()`。有关模式，请参阅ooxml.md中的**"文档库"**部分。

   **注意**：在编写脚本之前始终grep `word/document.xml`以获取当前行号并验证文本内容。每次脚本运行后行号都会更改。

5. **打包文档**：所有批次完成后，将解包的目录转换回.docx：
   ```bash
   python ooxml/scripts/pack.py 解包目录 审查文档.docx
   ```

6. **最终验证**：对完整文档进行全面检查：
   - 将最终文档转换为markdown：
     ```bash
     pandoc --track-changes=all 审查文档.docx -o 验证.md
     ```
   - 验证所有更改是否正确应用：
     ```bash
     grep "原始短语" 验证.md  # 不应找到
     grep "替换短语" 验证.md  # 应找到
     ```
   - 检查是否引入了意外的更改

## 将文档转换为图像

为了可视化分析Word文档，使用两步过程将它们转换为图像：

1. **将DOCX转换为PDF**：
   ```bash
   soffice --headless --convert-to pdf 文档.docx
   ```

2. **将PDF页面转换为JPEG图像**：
   ```bash
   pdftoppm -jpeg -r 150 文档.pdf 页面
   ```
   这将创建类似`页面-1.jpg`、`页面-2.jpg`等的文件。

选项：
- `-r 150`：设置分辨率为150 DPI（调整质量/大小平衡）
- `-jpeg`：输出JPEG格式（如果首选PNG，请使用`-png`）
- `-f N`：要转换的第一页（例如`-f 2`从第2页开始）
- `-l N`：要转换的最后一页（例如`-l 5`在第5页停止）
- `页面`：输出文件的前缀

特定范围的示例：
```bash
pdftoppm -jpeg -r 150 -f 2 -l 5 文档.pdf 页面  # 仅转换第2-5页
```

## 代码风格指南
**重要**：为DOCX操作生成代码时：
- 编写简洁的代码
- 避免冗长的变量名和冗余操作
- 避免不必要的打印语句

### 文档结构
- 使用清晰的标题层次结构（H1-H6）
- 保持段落简洁，每段不超过5-7行
- 使用列表和表格组织复杂信息

### 代码块格式
- 使用适当的语法高亮
- 包含必要的导入语句
- 提供清晰的注释说明

### 技术术语一致性
- 保持术语翻译的一致性
- 使用行业标准术语
- 避免创造新的技术术语

## 最佳实践

### 文档结构
- **使用标准段落标记**：`<w:p>`用于段落，`<w:r>`用于文本运行
- **保持样式一致性**：重用现有样式而不是创建新样式
- **处理分页**：注意分页符和节分隔符的位置

### 内容处理
- **文本编码**：确保正确处理Unicode字符
- **图像处理**：将图像添加到`word/media/`目录并更新关系文件
- **表格处理**：使用适当的表格结构标记

### 错误预防
- **验证XML**：每次修改后验证XML结构
- **测试兼容性**：在不同版本的Word中测试生成的文档
- **备份原始文件**：在编辑前保留原始文档的备份

## 依赖项

必需的依赖项（如果不可用则安装）：

- **pandoc**：`sudo apt-get install pandoc`（用于文本提取）
- **docx**：`npm install -g docx`（用于创建新文档）
- **LibreOffice**：`sudo apt-get install libreoffice`（用于PDF转换）
- **Poppler**：`sudo apt-get install poppler-utils`（用于pdftoppm将PDF转换为图像）
- **defusedxml**：`pip install defusedxml`（用于安全XML解析）

## 故障排除

### 常见问题
- **文档无法打开**：检查XML语法错误和文件关系
- **格式丢失**：验证样式定义和引用
- **图像不显示**：检查媒体文件路径和关系

### 调试技巧
- **逐步验证**：每次修改后验证文档
- **比较原始文件**：与工作正常的文档进行比较
- **使用XML验证工具**：利用提供的验证脚本检查错误